<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D ä¹é«˜æ„å»ºå™¨ - å®Œç¾è§¦æ§ç‰ˆ</title>
    <style>
        :root {
            --ui-bg: rgba(255, 255, 255, 0.95);
            --ui-shadow: 0 4px 15px rgba(0,0,0,0.2);
            --primary-color: #007bff;
            --danger-color: #d9534f;
        }
        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #e0e0e0;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
            position: absolute;
            top: 0; left: 0;
            z-index: 1;
            outline: none;
        }

        /* --- UI æ ·å¼ä¿æŒä¸å˜ --- */
        .ui-panel-base {
            background: var(--ui-bg);
            padding: 12px;
            border-radius: 12px;
            box-shadow: var(--ui-shadow);
            backdrop-filter: blur(5px);
            z-index: 10;
        }

        h2 { margin: 0 0 10px 0; font-size: 16px; color: #333; border-bottom: 1px solid #eee; padding-bottom: 5px;}
        h3 { font-size: 13px; color: #666; margin: 10px 0 5px 0;}
        label { font-size: 12px; font-weight: bold; display: block; margin-bottom: 3px;}

        .scroll-container {
            display: flex; gap: 8px; overflow-x: auto; padding: 5px 2px;
            scrollbar-width: none; -ms-overflow-style: none;
        }
        .scroll-container::-webkit-scrollbar { display: none; }

        .color-btn {
            flex: 0 0 auto; width: 32px; height: 32px; border-radius: 50%; 
            border: 3px solid #fff; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: transform 0.1s;
        }
        .color-btn.active { border-color: #333; transform: scale(1.1); }

        .size-btn {
            flex: 0 0 auto; padding: 6px 12px; border: 1px solid #ccc; background: #f8f8f8;
            cursor: pointer; font-size: 13px; border-radius: 20px; font-weight: 500;
        }
        .size-btn.active { background: var(--primary-color); color: white; border-color: var(--primary-color); }

        .action-btn {
            padding: 10px; background: var(--primary-color); color: white; border: none;
            border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 14px;
            display: flex; align-items: center; justify-content: center;
        }
        .action-btn:active { filter: brightness(0.9); }
        .btn-danger { background: var(--danger-color); }
        .btn-danger.active { background: #c9302c; box-shadow: inset 0 3px 5px rgba(0,0,0,0.2); }

        input[type="number"] { width: 50px; padding: 6px; border: 1px solid #ccc; border-radius: 6px; text-align: center;}

        #desktop-sidebar {
            display: none; position: absolute; top: 10px; left: 10px; width: 240px; max-height: 90vh; overflow-y: auto;
        }

        #mobile-toolbar {
            position: absolute; bottom: 0; left: 0; width: 100%;
            border-radius: 16px 16px 0 0; padding-bottom: env(safe-area-inset-bottom, 10px);
            display: flex; flex-direction: column; gap: 10px;
        }
        
        .main-actions { display: flex; gap: 10px; }
        .main-actions .action-btn { flex: 1; height: 44px; }

        #settings-toggle-btn {
            position: absolute; top: 10px; right: 10px; z-index: 20;
            padding: 8px; background: white; border-radius: 8px; box-shadow: var(--ui-shadow); cursor: pointer;
        }

        #mobile-settings-panel {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 80%; max-width: 300px; z-index: 30;
        }

        @media (min-width: 769px) {
            #desktop-sidebar { display: block; }
            #mobile-toolbar { display: none; }
            #settings-toggle-btn { display: none; }
            .scroll-container { flex-wrap: wrap; overflow-x: visible; justify-content: flex-start;}
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="desktop-sidebar" class="ui-panel-base ui-area">
        <h2>ä¹é«˜æ„å»ºå™¨ (PC)</h2>
        <div id="desktop-controls-container"></div>
        <div class="control-group">
             <h3>è¯´æ˜</h3>
             <div style="font-size: 11px; color: #666; background: #eee; padding: 8px; border-radius: 4px;">
                 å·¦é”®ç‚¹å‡»: æ”¾ç½®<br>æ‹–åŠ¨: æ—‹è½¬è§†è§’<br>Ré”®: æ—‹è½¬ç§¯æœ¨
             </div>
        </div>
    </div>

    <div id="settings-toggle-btn" class="ui-area" onclick="toggleSettingsPanel()">âš™ï¸ è®¾ç½®</div>

    <div id="mobile-settings-panel" class="ui-panel-base ui-area">
        <h2>åœºæ™¯è®¾ç½®</h2>
        <div id="settings-controls-container"></div>
        <button class="action-btn btn-danger" style="margin-top:15px; width:100%" onclick="toggleSettingsPanel()">å…³é—­</button>
    </div>

    <div id="mobile-toolbar" class="ui-panel-base ui-area">
        <div class="main-actions">
            <button class="action-btn" id="btn-rotate" onclick="rotateBrick()">ğŸ”„ æ—‹è½¬</button>
            <button class="action-btn btn-danger" id="btn-delete-mode" onclick="toggleDeleteMode()">ğŸ—‘ï¸ åˆ é™¤: å…³</button>
        </div>
        <div id="color-container-wrapper"></div>
        <div id="size-container-wrapper"></div>
    </div>

    <div id="canvas-container"></div>

    <div style="display:none;">
        <div id="tpl-color-controls" class="control-group">
            <h3>é¢œè‰²</h3><div class="scroll-container" id="color-palette"></div>
        </div>
        <div id="tpl-size-controls" class="control-group">
            <h3>å°ºå¯¸</h3>
            <div class="scroll-container" id="size-controls">
                <button class="size-btn active" data-w="1" data-d="1">1x1</button>
                <button class="size-btn" data-w="2" data-d="1">2x1</button>
                <button class="size-btn" data-w="3" data-d="1">3x1</button>
                <button class="size-btn" data-w="4" data-d="1">4x1</button>
                <button class="size-btn" data-w="2" data-d="2">2x2</button>
                <button class="size-btn" data-w="2" data-d="4">2x4</button>
                <button class="size-btn" data-w="4" data-d="4">4x4</button>
            </div>
        </div>
        <div id="tpl-settings-controls" class="control-group">
            <h3>åº•æ¿è®¾ç½®</h3>
            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                <div><label>å®½</label><input type="number" id="base-w" value="20" min="5" max="100"></div>
                <div><label>æ·±</label><input type="number" id="base-d" value="20" min="5" max="100"></div>
                <button class="action-btn" style="flex:1; background:#28a745;" onclick="updateBaseplate()">æ›´æ–°</button>
            </div>
            <button class="action-btn btn-danger" style="width:100%;" onclick="clearScene()">æ¸…ç©ºæ‰€æœ‰</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, raycaster, mouse, controls;
        let plane, gridHelper;
        let rollOverMesh, rollOverMaterial;
        let brickMaterialPhong;
        const objects = [];
        
        const unitSize = 20;
        let currentBrickColor = 0xd01010;
        let currentBrickSize = { w: 1, d: 1, h: 1.2 };
        let isRotated = false;
        let isDeleteMode = false;
        let isMobile = window.innerWidth < 769;

        // æ ¸å¿ƒäº¤äº’å˜é‡ï¼šç”¨äºåŒºåˆ†æ‹–æ‹½å’Œç‚¹å‡»
        let pointerDownPos = new THREE.Vector2();
        let isOrbiting = false; // æ˜¯å¦æ­£åœ¨æ—‹è½¬è§†è§’

        const colors = [
            0xd01010, 0x0055bf, 0xffd010, 0x008f30, 0xffffff, 
            0x111111, 0x9ba1a6, 0xff8010, 0x8a2be2
        ];

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xeaddca);
            scene.fog = new THREE.Fog(0xeaddca, 1000, 5000);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.set(600, 800, 1000);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.useLegacyLights = false;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffeedd, 0.8);
            scene.add(ambientLight);

            const mainLight = new THREE.DirectionalLight(0xffffff, 2.0);
            mainLight.position.set(100, 200, 100);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048; 
            mainLight.shadow.mapSize.height = 2048;
            scene.add(mainLight);
            
            const fillLight = new THREE.DirectionalLight(0xccccff, 0.5);
            fillLight.position.set(-100, 50, -100);
            scene.add(fillLight);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            createBaseplate(20, 20);
            updateBrickMaterial();
            initRollOverMesh();

            // ç»‘å®šäº‹ä»¶ - ä½¿ç”¨ Pointer Events ç»Ÿä¸€é¼ æ ‡å’Œè§¦æ‘¸
            const canvas = renderer.domElement;
            canvas.addEventListener('pointermove', onPointerMove);
            // å…³é”®ä¿®æ”¹ï¼šåˆ†å¼€ down å’Œ up å¤„ç†
            canvas.addEventListener('pointerdown', onPointerDown);
            canvas.addEventListener('pointerup', onPointerUp);
            
            document.addEventListener('keydown', onDocumentKeyDown);
            window.addEventListener('resize', onWindowResize);

            initUI();

            controls = new OrbitControls(camera, canvas);
            controls.enableDamping = true; 
            controls.dampingFactor = 0.1;
            controls.rotateSpeed = 0.7; 
            
            // ç›‘å¬æ§åˆ¶å™¨çŠ¶æ€ï¼Œæ—‹è½¬æ—¶éšè—é¢„è§ˆæ¡†ï¼Œé¿å…è§†è§‰å¹²æ‰°
            controls.addEventListener('start', () => { isOrbiting = true; rollOverMesh.visible = false; });
            controls.addEventListener('end', () => { isOrbiting = false; updateRollOverVisibility(); });
        }

        function updateBrickMaterial() {
            brickMaterialPhong = new THREE.MeshPhongMaterial({
                color: currentBrickColor,
                specular: 0x666666,
                shininess: 80,
                flatShading: false
            });
        }

        function createBaseplate(widthUnits, depthUnits) {
            if(plane) scene.remove(plane);
            if(gridHelper) scene.remove(gridHelper);
            const oldPlaneIndex = objects.findIndex(obj => obj.userData.isGround);
            if(oldPlaneIndex > -1) objects.splice(oldPlaneIndex, 1);

            const w = widthUnits * unitSize;
            const d = depthUnits * unitSize;

            gridHelper = new THREE.GridHelper(Math.max(w, d), Math.max(widthUnits, depthUnits), 0xbbbbbb, 0xdddddd);
            scene.add(gridHelper);

            const geometry = new THREE.PlaneGeometry(w, d);
            geometry.rotateX(-Math.PI / 2);
            plane = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({ color: 0xf0f0f0, specular: 0x111111, shininess: 10 }));
            plane.receiveShadow = true;
            plane.userData = { isGround: true };
            scene.add(plane);
            objects.push(plane);
        }

        function initRollOverMesh() {
            if(rollOverMesh) scene.remove(rollOverMesh);
            rollOverMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, opacity: 0.5, transparent: true, depthTest: false });
            
            const wUnits = isRotated ? currentBrickSize.d : currentBrickSize.w;
            const dUnits = isRotated ? currentBrickSize.w : currentBrickSize.d;
            const w = wUnits * unitSize;
            const d = dUnits * unitSize;
            const h = currentBrickSize.h * unitSize;

            const geo = new THREE.BoxGeometry(w, h, d);
            geo.translate(0, h / 2, 0);
            rollOverMesh = new THREE.Mesh(geo, rollOverMaterial);
            rollOverMesh.renderOrder = 999; 
            scene.add(rollOverMesh);
        }

        function createLegoBrick(sizeW, sizeD) {
            const w = sizeW * unitSize;
            const d = sizeD * unitSize;
            const h = 1.2 * unitSize;

            const group = new THREE.Group();
            const baseGeo = new THREE.BoxGeometry(w, h, d);
            baseGeo.translate(0, h / 2, 0);
            const baseMesh = new THREE.Mesh(baseGeo, brickMaterialPhong);
            baseMesh.castShadow = true;
            baseMesh.receiveShadow = true;
            group.add(baseMesh);

            const studGeo = new THREE.CylinderGeometry(4.2, 4.2, 3.5, 32);
            studGeo.translate(0, 3.5 / 2, 0);

            const startX = -(w/2) + unitSize/2;
            const startZ = -(d/2) + unitSize/2;

            for(let i=0; i<sizeW; i++) {
                for(let j=0; j<sizeD; j++) {
                    const stud = new THREE.Mesh(studGeo, brickMaterialPhong);
                    stud.position.x = startX + i * unitSize;
                    stud.position.z = startZ + j * unitSize;
                    stud.position.y = h - 0.1; 
                    stud.castShadow = true;
                    stud.receiveShadow = true;
                    group.add(stud);
                }
            }

            group.userData = { isBrick: true, wUnits: sizeW, dUnits: sizeD };
            return group;
        }

        // --- æ ¸å¿ƒäº¤äº’é€»è¾‘ä¿®æ”¹ ---

        function onPointerDown(event) {
            // è®°å½•æŒ‰ä¸‹çš„ä½ç½®ï¼Œä¸åšä»»ä½•æ”¾ç½®æ“ä½œ
            if(event.target.closest('.ui-area')) return;
            pointerDownPos.set(event.clientX, event.clientY);
        }

        function onPointerMove(event) {
            // æ›´æ–°é¼ æ ‡ä½ç½®ï¼Œç”¨äºå°„çº¿æ£€æµ‹
            updatePointerPosition(event);

            // å¦‚æœæ­£åœ¨æ—‹è½¬è§†è§’ï¼Œä¸è¿›è¡Œå°„çº¿æ£€æµ‹ï¼Œç›´æ¥è¿”å›
            if (isOrbiting) return;
            if (isMobile && !event.isPrimary) return; // å¿½ç•¥å¤šæŒ‡æ“ä½œ

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(objects, true);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                const normal = intersect.face.normal;
                
                const voxelPos = new THREE.Vector3().copy(intersect.point).add(normal.clone().multiplyScalar(unitSize * 0.1));
                
                rollOverMesh.position.x = Math.floor(voxelPos.x / unitSize) * unitSize + unitSize / 2;
                rollOverMesh.position.z = Math.floor(voxelPos.z / unitSize) * unitSize + unitSize / 2;
                
                if (intersect.object.userData.isGround || (intersect.object.parent && intersect.object.parent.userData.isGround)) {
                    rollOverMesh.position.y = 0;
                } else {
                    rollOverMesh.position.y = Math.floor(intersect.point.y / unitSize) * unitSize;
                    if(normal.y > 0.8 && (intersect.point.y % unitSize) > unitSize * 0.8 ) {
                         rollOverMesh.position.y += unitSize;
                    }
                }

                const wUnits = isRotated ? currentBrickSize.d : currentBrickSize.w;
                const dUnits = isRotated ? currentBrickSize.w : currentBrickSize.d;
                if (wUnits % 2 === 0) rollOverMesh.position.x += unitSize / 2;
                if (dUnits % 2 === 0) rollOverMesh.position.z += unitSize / 2;

                updateRollOverVisibility();
            } else {
                 if(!isDeleteMode) rollOverMesh.visible = false;
            }
        }

        function onPointerUp(event) {
            if(event.target.closest('.ui-area')) return;
            
            // 1. è®¡ç®—ç§»åŠ¨è·ç¦»
            const moveX = Math.abs(event.clientX - pointerDownPos.x);
            const moveY = Math.abs(event.clientY - pointerDownPos.y);
            const distance = Math.sqrt(moveX * moveX + moveY * moveY);

            // 2. é˜ˆå€¼åˆ¤æ–­ï¼šå¦‚æœç§»åŠ¨è¶…è¿‡ 5 åƒç´ ï¼Œè®¤ä¸ºæ˜¯æ‹–æ‹½(æ—‹è½¬è§†è§’)ï¼Œä¸æ‰§è¡Œæ”¾ç½®/åˆ é™¤
            if (distance > 5) return;

            // 3. æ‰§è¡Œç‚¹å‡»é€»è¾‘ (æ”¾ç½®æˆ–åˆ é™¤)
            // æ­¤æ—¶é‡æ–°è¿›è¡Œä¸€æ¬¡å°„çº¿æ£€æµ‹ï¼Œç¡®ä¿ä½ç½®æœ€å‡†ç¡®
            updatePointerPosition(event);
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(objects, true);

            if (intersects.length > 0) {
                const intersect = intersects[0];

                // åˆ é™¤æ¨¡å¼
                if (event.shiftKey || isDeleteMode) {
                    let target = intersect.object;
                    while(target.parent && target.parent !== scene) {
                        if(target.userData.isBrick || target.userData.isGround) break;
                        target = target.parent;
                    }
                    if (target.userData.isBrick) {
                        scene.remove(target);
                        objects.splice(objects.indexOf(target), 1);
                        if(isMobile && navigator.vibrate) navigator.vibrate(30);
                    }
                    return;
                }

                // æ”¾ç½®æ¨¡å¼
                const wUnits = isRotated ? currentBrickSize.d : currentBrickSize.w;
                const dUnits = isRotated ? currentBrickSize.w : currentBrickSize.d;
                
                const brick = createLegoBrick(wUnits, dUnits);
                // ç¡®ä¿å¯¹é½
                onPointerMove(event); 
                brick.position.copy(rollOverMesh.position);
                
                scene.add(brick);
                objects.push(brick);
                if(isMobile && navigator.vibrate) navigator.vibrate(15);
            }
        }

        function updatePointerPosition(event) {
            let clientX = event.clientX;
            let clientY = event.clientY;
            if (event.isPrimary === false && event.touches && event.touches.length > 0) {
                 // å¤„ç†æŸäº›è¾¹ç¼˜æƒ…å†µ
            }
            mouse.set((clientX / window.innerWidth) * 2 - 1, -(clientY / window.innerHeight) * 2 + 1);
        }
        
        function updateRollOverVisibility() {
            // åªæœ‰åœ¨éåˆ é™¤æ¨¡å¼ä¸”éè½¨é“æ—‹è½¬æ—¶æ‰æ˜¾ç¤ºé¢„è§ˆ
            if (!isDeleteMode && !isOrbiting) {
                rollOverMesh.visible = true;
            } else {
                rollOverMesh.visible = false;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            isMobile = window.innerWidth < 769;
            adjustUILayout();
        }

        function onDocumentKeyDown(event) {
            if (event.code === 'KeyR') rotateBrick();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // --- å…¨å±€ UI é€»è¾‘ ---
        window.rotateBrick = function() {
            isRotated = !isRotated;
            rollOverMesh.rotation.y = isRotated ? -Math.PI / 2 : 0;
            initRollOverMesh();
            rollOverMesh.rotation.y = isRotated ? -Math.PI / 2 : 0; 
        }

        window.toggleDeleteMode = function() {
            isDeleteMode = !isDeleteMode;
            const btn = document.getElementById('btn-delete-mode');
            if(isDeleteMode) {
                btn.classList.add('active');
                btn.innerHTML = 'ğŸ—‘ï¸ åˆ é™¤æ¨¡å¼: å¼€';
                document.body.style.cursor = 'not-allowed';
            } else {
                btn.classList.remove('active');
                btn.innerHTML = 'ğŸ—‘ï¸ åˆ é™¤æ¨¡å¼: å…³';
                document.body.style.cursor = 'auto';
            }
            updateRollOverVisibility();
        }
        
        window.updateBaseplate = function() {
            const w = parseInt(document.getElementById('base-w').value) || 20;
            const d = parseInt(document.getElementById('base-d').value) || 20;
            createBaseplate(w, d);
            if(isMobile) toggleSettingsPanel();
        }

        window.clearScene = function() {
            if(!confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰ç§¯æœ¨å—ï¼Ÿ')) return;
            for (let i = objects.length - 1; i >= 0; i--) {
                const obj = objects[i];
                if (obj.userData.isBrick) {
                    scene.remove(obj);
                    objects.splice(i, 1);
                }
            }
            if(isMobile) toggleSettingsPanel();
        }

        window.toggleSettingsPanel = function() {
            const panel = document.getElementById('mobile-settings-panel');
            panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
        }

        function initUI() {
            const palette = document.getElementById('color-palette');
            colors.forEach((c, index) => {
                const btn = document.createElement('div');
                btn.className = 'color-btn' + (index === 0 ? ' active' : '');
                btn.style.backgroundColor = '#' + c.toString(16).padStart(6, '0');
                btn.onclick = () => {
                    document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentBrickColor = c;
                    updateBrickMaterial();
                    rollOverMesh.material.color.setHex(c);
                };
                palette.appendChild(btn);
            });

            const sizeBtns = document.querySelectorAll('.size-btn');
            sizeBtns.forEach(btn => {
                btn.onclick = () => {
                    sizeBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentBrickSize.w = parseInt(btn.dataset.w);
                    currentBrickSize.d = parseInt(btn.dataset.d);
                    isRotated = false;
                    rollOverMesh.rotation.y = 0;
                    initRollOverMesh();
                };
            });
            adjustUILayout();
        }

        function adjustUILayout() {
            const colorControls = document.getElementById('tpl-color-controls');
            const sizeControls = document.getElementById('tpl-size-controls');
            const settingsControls = document.getElementById('tpl-settings-controls');

            if (isMobile) {
                document.getElementById('color-container-wrapper').appendChild(colorControls);
                document.getElementById('size-container-wrapper').appendChild(sizeControls);
                document.getElementById('settings-controls-container').appendChild(settingsControls);
            } else {
                const desktopContainer = document.getElementById('desktop-controls-container');
                desktopContainer.appendChild(colorControls);
                desktopContainer.appendChild(sizeControls);
                desktopContainer.appendChild(settingsControls);
            }
        }
    </script>
</body>
</html>
