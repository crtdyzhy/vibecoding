<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Isometric ARPG Portrait Mode</title>
    <style>
        html, body { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            overflow: hidden; background: #222; touch-action: none; 
        }
        canvas { display: block; touch-action: none; }
        /* 移除之前的旋转提示CSS */
    </style>
    
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/phaser3-rex-plugins@1.1.91/dist/rexvirtualjoystickplugin.min.js"></script>
</head>
<body>

<div id="game-container"></div>

<script>
const CONFIG = {
    moveSpeed: 160,
    playerColor: 0x00ff00, 
    enemyColor: 0xff0000,
};

class MainScene extends Phaser.Scene {
    constructor() {
        super({ key: 'MainScene' });
    }

    create() {
        // 1. 背景与世界
        this.createIsoBackground();

        // 2. 玩家
        this.player = this.add.rectangle(400, 300, 30, 30, CONFIG.playerColor);
        this.physics.add.existing(this.player);
        this.player.body.setCollideWorldBounds(true);
        // 玩家影子
        this.playerShadow = this.add.ellipse(400, 300, 30, 15, 0x000000, 0.3);
        
        this.player.hp = 100;
        this.player.maxHp = 100;

        // 3. 敌人
        this.enemies = this.physics.add.group();
        this.createEnemy(600, 400);
        this.createEnemy(200, 500);
        this.createEnemy(300, 700); // 多加一个敌人

        // 4. 摄像机 (调整缩放以适应竖屏视野)
        this.cameras.main.startFollow(this.player, true, 0.05, 0.05);
        this.cameras.main.setZoom(1.0); // 竖屏视野窄，稍微拉远一点点或保持1.0

        // 5. 初始化UI (竖屏布局核心)
        this.createPortraitUI();

        // 6. 交互
        this.physics.add.overlap(this.player, this.enemies, this.onTouchEnemy, null, this);
    }

    createIsoBackground() {
        const graphics = this.add.graphics();
        graphics.lineStyle(1, 0x444444, 1);
        const gridSize = 40;
        const width = 2000;
        const height = 2000;
        
        this.physics.world.setBounds(0, 0, width, height);
        
        graphics.beginPath();
        for (let x = 0; x <= width; x += gridSize) {
            graphics.moveTo(x, 0);
            graphics.lineTo(x, height);
        }
        for (let y = 0; y <= height; y += gridSize) {
            graphics.moveTo(0, y);
            graphics.lineTo(width, y);
        }
        graphics.strokePath();
        this.add.rectangle(width/2, height/2, width, height, 0x222222).setDepth(-1);
    }

    createEnemy(x, y) {
        let enemy = this.add.rectangle(x, y, 30, 30, CONFIG.enemyColor);
        this.physics.add.existing(enemy);
        enemy.hp = 50;
        enemy.maxHp = 50;
        enemy.hpBarBg = this.add.rectangle(x, y - 25, 40, 6, 0x000000);
        enemy.hpBarFg = this.add.rectangle(x, y - 25, 38, 4, 0xff0000);
        this.enemies.add(enemy);
    }

    // --- 核心修改：竖屏 UI 布局 ---
    createPortraitUI() {
        const width = this.scale.width;
        const height = this.scale.height;

        // 1. 摇杆：放在屏幕底部正中间
        // 半径稍微调小一点，避免占据太多屏幕
        this.joyStick = this.plugins.get('rexVirtualJoystick').add(this, {
            x: width / 2,
            y: height - 100, // 距离底部100像素
            radius: 50,
            base: this.add.circle(0, 0, 50, 0x888888, 0.5).setDepth(100),
            thumb: this.add.circle(0, 0, 25, 0xcccccc, 0.8).setDepth(101),
        }).on('update', this.handleJoystick, this);

        // 2. 技能按钮组
        this.skillBtns = []; // 初始化数组

        // 普攻 (Attack) - 放在右下角，摇杆的右侧
        // 位置：右下，稍微大一点
        this.createSkillBtn(width - 60, height - 80, 40, 0xffaa00, '攻', () => this.doAttack());

        // 技能1 (Skill 1) - 放在左下角，摇杆的左侧
        this.createSkillBtn(60, height - 80, 30, 0x00aaff, '技1', () => this.castSkill(1));

        // 技能2 (Skill 2) - 放在普攻的上方 (右侧)
        this.createSkillBtn(width - 60, height - 160, 30, 0x00aaff, '技2', () => this.castSkill(2));

        // 技能3 (Skill 3) - 放在技能1的上方 (左侧)
        this.createSkillBtn(60, height - 160, 30, 0xff00ff, '闪', () => this.castSkill(3));

        // 3. 玩家状态栏 (Top UI)
        this.uiContainer = this.add.container(0, 0).setScrollFactor(0).setDepth(200);
        
        // 简单的顶部通栏背景
        let topBar = this.add.rectangle(width/2, 30, width, 60, 0x000000, 0.5);
        
        // 头像
        let avatar = this.add.rectangle(30, 30, 40, 40, 0x444444);
        let name = this.add.text(60, 15, "Player 1", { fontSize: '14px', fill: '#fff' });
        
        // 血条 (自适应宽度)
        let hpBg = this.add.rectangle(width/2 + 20, 40, width - 120, 10, 0x333333);
        this.playerHpBar = this.add.rectangle(width/2 + 20, 40, width - 120, 10, 0x00ff00); // 初始满血
        this.playerHpBar.maxWidth = width - 120; // 记录最大宽度用于计算

        this.uiContainer.add([topBar, avatar, name, hpBg, this.playerHpBar]);

        // 注册 Resize 事件，处理屏幕旋转或大小变化
        this.scale.on('resize', this.resizeUI, this);
    }

    createSkillBtn(x, y, radius, color, text, callback) {
        let btn = this.add.circle(x, y, radius, color, 0.7)
            .setScrollFactor(0)
            .setInteractive()
            .setDepth(100);
        let label = this.add.text(x, y, text, { fontSize: '14px', fontStyle: 'bold', color: '#000' })
            .setOrigin(0.5).setScrollFactor(0).setDepth(101);

        btn.on('pointerdown', () => { btn.setScale(0.9); callback(); });
        btn.on('pointerup', () => btn.setScale(1));
        
        // 记录相对位置，用于resize
        // 我们记录它相对于 屏幕宽度(w) 和 高度(h) 的比例或偏移
        // 这里简单记录它应该是 "Left/Right" 和 "Bottom" 的偏移
        const isRight = x > this.scale.width / 2;
        this.skillBtns.push({
            btn, label, 
            offsetX: isRight ? x - this.scale.width : x, // 右侧存负值，左侧存正值
            offsetY: y - this.scale.height // 存底部偏移(负值)
        });
    }

    resizeUI(gameSize) {
        const width = gameSize.width;
        const height = gameSize.height;

        // 1. 重置摇杆到中下方
        if (this.joyStick) {
            this.joyStick.setPosition(width / 2, height - 100);
        }

        // 2. 重置按钮位置
        if (this.skillBtns) {
            this.skillBtns.forEach(item => {
                // 如果 offsetX 是负数，说明是靠右的，加上新宽度；如果是正数，说明靠左，保持不变
                const newX = item.offsetX < 0 ? width + item.offsetX : item.offsetX;
                const newY = height + item.offsetY;
                
                item.btn.setPosition(newX, newY);
                item.label.setPosition(newX, newY);
            });
        }

        // 3. 重置血条 UI
        // 这里简化处理，直接刷新整个场景可能更方便，但为了演示，我们只调整血条背景位置
        // 实际项目中建议重绘 UI Container
    }

    handleJoystick() {
        const force = this.joyStick.force;
        if (force > 0) {
            this.scene.scene.physics.velocityFromRotation(this.joyStick.rotation, CONFIG.moveSpeed, this.player.body.velocity);
        } else {
            this.player.body.set